<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在docker里运行Jenkins]]></title>
    <url>%2F2017%2F12%2F23%2Fdocker-jenkins%2F</url>
    <content type="text"><![CDATA[Jenkins12docker run -d -p "12821:8080" --name jenkins jenkins/jenkins5cc5e09fdea5e9296bd26095b90f770b0d05213d80299d44dd3984db14bdbd85 然后登陆到容器里获取初始化密码: 1234567docker exec -it 5cc5e09fdea5 bash#使用cat 命令查看密码jenkins@5cc5e09fdea5:/$ cat /var/jenkins_home/secrets/initialAdminPassword#然后出来这个密码44fcdb88xxxxxxxxxxx6a2d00c2d 把上面的密码复制到浏览器里http://localhost:12821 里需要密码的地方:]]></content>
      <categories>
        <category>Docker</category>
        <category>部署例子</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门-part5-Stacks]]></title>
    <url>%2F2017%2F12%2F22%2Fdocker-part5%2F</url>
    <content type="text"><![CDATA[Stacks前言本Docker入门系列文章是翻译于Docker官方getStarted文档,如有出入，请跳转查看官方文档 简单介绍 A stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. 可以理解一个堆里有多个服务，服务之间相互协作。有一些复杂的应用，它可能需要多个堆。 添加一个新的服务并且部署它1.我们打开之前的docker-compose.yml文件，使用下面的代码覆盖它。记得替换那里username/repo:tag 对应的远程库镜像值。 123456789101112131415161718192021222324252627282930version: "3"services: web: # replace username/repo:tag with your name and image details image: username/repo:tag deploy: replicas: 5 restart_policy: condition: on-failure resources: limits: cpus: "0.1" memory: 50M ports: - "80:80" networks: - webnet visualizer: image: dockersamples/visualizer:stable ports: - "8080:8080" volumes: - "/var/run/docker.sock:/var/run/docker.sock" deploy: placement: constraints: [node.role == manager] networks: - webnetnetworks: webnet: 我们可以看到上面的代码里，多了一个服务：visualizer。并且看到一个新的关键字volumes ,它给visualizer容器权限，能访问宿主机的socket文件。还有一个新的关键字placement,定义这个服务只能在swarm manager上运行，不能在worker上。因为这个容器是用来展示Docker的各种服务在一个图表里，它由Docker开发的并且开源。 2.设置你的shell连接上myvm1 ，上部分已经讲过： docker-machine ls docker-machine env myvm1 eval $(docker-machine env myvm1) 3.在manager节点上再次运行docker stack deploy,如下： 1docker stack deploy -c docker-compose.yml getstartedlab 4.我们来看看visualizer先使用docker-machine ls查看各个节点的ip,然后你用浏览访问任何一个ip的8080端口，就可以看到图像化界面，显示各种服务在不同的机器上运行。 我们可以看到,visualizer只运行在manager节点上。 可以使用docker stack ps getstartedlab查看该堆所有服务的任务。 持久化数据让我们添加一个Redis 数据库 用来存储数据 1.我们打开之前的docker-compose.yml文件，使用下面的代码覆盖它。记得替换那里username/repo:tag 对应的远程库镜像值。 123456789101112131415161718192021222324252627282930313233343536373839404142version: "3"services: web: # replace username/repo:tag with your name and image details image: username/repo:tag deploy: replicas: 5 restart_policy: condition: on-failure resources: limits: cpus: "0.1" memory: 50M ports: - "80:80" networks: - webnet visualizer: image: dockersamples/visualizer:stable ports: - "8080:8080" volumes: - "/var/run/docker.sock:/var/run/docker.sock" deploy: placement: constraints: [node.role == manager] networks: - webnet redis: image: redis ports: - "6379:6379" volumes: - /home/docker/data:/data deploy: placement: constraints: [node.role == manager] command: redis-server --appendonly yes networks: - webnetnetworks: webnet: 2.在manager机器上（即myvm1）,创建一个目录：./data 1docker-machine ssh myvm1 "mkdir ./data" 这里注意几点: redis 的远程镜像就是很短：”redis”,不用质疑 redis容器对外服务端口依然是6379,方便其他服务获取。 redis的volumes 的/home/docker/data目录是myvm1的目录，因为下面定义了它只能部署在manager上，所以我们使用docker-machine ssh myvm1 &quot;mkdir ./data&quot; 创建一个/home/docker/data目录。然后冒号后边的/data是redis容器里的路径，这里是redis的工作路径，我们不用管。 3.保证你的shell连接上myvm1 ,前面讲过 4.重新部署,再次执行： 1docker stack deploy -c docker-compose.yml getstartedlab 5.查看服务： 1docker service ls 6.访问你的一个节点机器 http://192.168.99.101 ,我们可以看到Visits在递增，那是因为我们的数据存在Redis上了。我们继续看看http://192.168.99.101:8080]]></content>
      <categories>
        <category>Docker</category>
        <category>Docker入门</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门-part4-Swarms]]></title>
    <url>%2F2017%2F12%2F22%2Fdocker-part4%2F</url>
    <content type="text"><![CDATA[Swarms前言本Docker入门系列文章是翻译于Docker官方getStarted文档,如有出入，请跳转查看官方文档 简单介绍 Here in part 4, you deploy this application onto a cluster, running it on multiple machines. Multi-container, multi-machine applications are made possible by joining multiple machines into a “Dockerized” cluster called a swarm. 可以理解swarm 是一个种多宿主机器，多容器组成的机器群体。 你可以通过 Swarm manager来控制这种多容器，多机器组成的集群。这里的机器可以是真实的也可以是虚拟的。一旦加入了swarm ，就称为一个节点node。 建立你的swarm在你的机器上执行docker swarm init去启动swarm 模式，且成为swarm manager。使用其他的机器执行docker swarm join加入刚刚的swarm 群里成为worker。这里 我们使用虚拟机模拟一个由两台机器组成的集群。 创建cluster MAC, LINUX 先在宿主机上安装VirtualBox 使用docker-machine 命令，和VirtualBox的驱动： 12docker-machine create --driver virtualbox myvm1docker-machine create --driver virtualbox myvm2 使用以下命令获得机器列表和他们的ip 12345$docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 - virtualbox Running tcp://192.168.99.100:2376 v17.11.0-ce myvm2 - virtualbox Running tcp://192.168.99.101:2376 v17.11.0-ce 初始化swarm 和添加节点 我们让myvm1成为manger,myvm2成为worker可以使用docker-machine ssh向 myvm1 发送docker swarm init命令格式是docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot; 12345678 $ docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.99.100"Swarm initialized: current node (qkxdnhw56ibpdwqt22jpvxtj6) is now a manager.To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-547x8uwxy9kjkf31c46q9bx74jb92v16y2ruoo6aabvv5rhq1r-36qjytbfe7i3dxu8tdp9fyfnr 192.168.99.100:2377To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. 同样地，我们向myvm2发送命令加入swarm,格式是： 123docker-machine ssh myvm2 "docker swarm join \--token &lt;token&gt; \&lt;ip&gt;:2377" 123$ docker-machine ssh myvm2 "docker swarm join --token SWMTKN-1-547x8uwxy9kjkf31c46q9bx74jb92v16y2ruoo6aabvv5rhq1r-36qjytbfe7i3dxu8tdp9fyfnr 192.168.99.100:2377"This node joined a swarm as a worker. 恭喜，你成功建立你的第一个swarm执行docker node ls 查看你的swarm中的各种节点: 12345$ docker-machine ssh myvm1 "docker node ls"ID HOSTNAME STATUS AVAILABILITY MANAGER STATUSqkxdnhw56ibpdwqt22jpvxtj6 * myvm1 Ready Active Leaderplax8po1p26hs67f693yqm5c7 myvm2 Ready Active 在你的swarm 集群部署你的APP上面艰难的步骤已经完了，接下来就简单了，重复Part3的步骤来部署在你新的swarm上，你只要记住，你的myvm1是管理者，只用来执行命令的，worker节点只是容纳过来的。他们都可以工作。 配置你的shell给swarm manager（可以理解为登陆到某个节点，不需要每次都docker-machine ssh） 这里提供mac / Linux的方法 1234567$ docker-machine env myvm1export DOCKER_TLS_VERIFY="1"export DOCKER_HOST="tcp://192.168.99.100:2376"export DOCKER_CERT_PATH="/Users/sam/.docker/machine/machines/myvm1"export DOCKER_MACHINE_NAME="myvm1"# Run this command to configure your shell:# eval $(docker-machine env myvm1) 然后运行 1eval $(docker-machine env myvm1) 现在你的shell已经登陆到myvm1上了，可以使用docker-machine ls 查看myvm1 的ACTIVE端是不是有个*号，表示你的shell登陆上这台机器 1234$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 * virtualbox Running tcp://192.168.99.100:2376 v17.11.0-ce myvm2 - virtualbox Running tcp://192.168.99.101:2376 v17.11.0-ce 在swarm manager机器上部署你的APP虽然你现在的shell已经登陆上myvm1 了，但是还是可以访问本机的文件，这里我们部署app就需要之前写的docker-compose.yml文件。我们使用以下命令： 1$docker stack deploy -c docker-compose.yml getstartedlab 我们成功部署了APP，在这个集群上。使用以下查看详细的部署： 12345678910$ docker stack ps getstartedlabID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSl546oo0pmewz getstartedlab_web.1 dk5664280/get-started:part2 myvm1 Running Preparing 25 seconds ago vdym3ibcbhku getstartedlab_web.2 dk5664280/get-started:part2 myvm2 Running Preparing 25 seconds ago x4gx5wzj7pp6 getstartedlab_web.3 dk5664280/get-started:part2 myvm2 Running Preparing 25 seconds ago imw4urn7oo9d getstartedlab_web.4 dk5664280/get-started:part2 myvm1 Running Preparing 26 seconds ago ios5s8yejbhj getstartedlab_web.5 dk5664280/get-started:part2 myvm2 Running Preparing 25 seconds ago vhkwaz09n4q8 getstartedlab_web.6 dk5664280/get-started:part2 myvm1 Running Preparing 25 seconds ago qybf5fd0ueij getstartedlab_web.7 dk5664280/get-started:part2 myvm2 Running Preparing 25 seconds ago 看到了，我们的app在补同的机器myvm1和myvm2上部署，它们组成了一个集群. 访问我们的集群你可以访问myvm1或myvm2,例如 http://192.168.99.100:4000或http://192.168.99.101:4000 ,你都可以得到返回结果，并且每次结果不一样，因为它们使用了swarm的一个负载均衡器。 重新调配你的app你可以修改你的docker-compose.yml,然后再运行 1docker stack deploy -c docker-compose.yml getstartedlab 清除和重启stacks 和swarms清除 stacks:docker stack rm getstartedlab 我们先不敢掉swarms,因为下一个Part 5,我们还用先保留以下。 如果你真想敢掉swarms,执行docker-machine ssh myvm2 &quot;docker swarm leave这样能使work机里开该swarm集群，docker-machine ssh myvm1 &quot;docker swarm leave --force 能使manager离开swarm 关掉所有机器执行下面的命令停止所有的机器： 1$docker-machine stop $(docker-machine ls -q) 清除shell配置1eval $(docker-machine env -u) 这样就可以中断连接虚拟机了。可以使用docker-machine ls查看，已经没有ACTIVE的机器了。 启动机器使用下面的代码启动机器 1docker-machine start &lt;machine-name&gt; socker是我打错了，ctrl+c 中断了该命令 总结123456789101112131415161718192021docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1 # Win10docker-machine env myvm1 # View basic information about your nodedocker-machine ssh myvm1 "docker node ls" # List the nodes in your swarmdocker-machine ssh myvm1 "docker node inspect &lt;node ID&gt;" # Inspect a nodedocker-machine ssh myvm1 "docker swarm join-token -q worker" # View join tokendocker-machine ssh myvm1 # Open an SSH session with the VM; type "exit" to enddocker node ls # View nodes in swarm (while logged on to manager)docker-machine ssh myvm2 "docker swarm leave" # Make the worker leave the swarmdocker-machine ssh myvm1 "docker swarm leave -f" # Make master leave, kill swarmdocker-machine ls # list VMs, asterisk shows which VM this shell is talking todocker-machine start myvm1 # Start a VM that is currently not runningdocker-machine env myvm1 # show environment variables and command for myvm1eval $(docker-machine env myvm1) # Mac command to connect shell to myvm1&amp; "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression # Windows command to connect shell to myvm1docker stack deploy -c &lt;file&gt; &lt;app&gt; # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose filedocker-machine scp docker-compose.yml myvm1:~ # Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app)docker-machine ssh myvm1 "docker stack deploy -c &lt;file&gt; &lt;app&gt;" # Deploy an app using ssh (you must have first copied the Compose file to myvm1)eval $(docker-machine env -u) # Disconnect shell from VMs, use native dockerdocker-machine stop $(docker-machine ls -q) # Stop all running VMsdocker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images]]></content>
      <categories>
        <category>Docker</category>
        <category>Docker入门</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门-part3-Services]]></title>
    <url>%2F2017%2F12%2F22%2Fdocker-part3%2F</url>
    <content type="text"><![CDATA[关于服务 About services前言本Docker入门系列文章是翻译于Docker官方getStarted文档,如有出入，请跳转查看官方文档 简单介绍 In a distributed application, different pieces of the app are called “services.” For example, if you imagine a video sharing site, it probably includes a service for storing application data in a database, a service for video transcoding in the background after a user uploads something, a service for the front-end, and so on.Services are really just “containers in production.” A service only runs one image, but it codifies the way that image runs—what ports it should use, how many replicas of the container should run so the service has the capacity it needs, and so on. Scaling a service changes the number of container instances running that piece of software, assigning more computing resources to the service in the process.Luckily it’s very easy to define, run, and scale services with the Docker platform – just write a docker-compose.yml file. 可以理解为，服务包含多个容器。一个服务通过docker-compose.yml创建，里面定义了多个容器的行为，资源消耗等问题。 编写你的 docker-compose.yml 文件这个文件定义了容器的行为 docker-compose.yml文件在你喜欢的目录下，创建 一个文件叫docker-compose.yml，使用你之前在Part 2推送的镜像，更新一下下面中username/repo:tag 的位置代码： 12345678910111213141516171819version: "3"services: web: #使用之前你推送的镜像路径 替代这里的 username/repo:tag image: username/repo:tag deploy: replicas: 5 resources: limits: cpus: "0.1" memory: 50M restart_policy: condition: on-failure ports: - "4000:80" networks: - webnetnetworks: webnet: 文件解释这个文件告诉docker 去做以下的事： 拉取远程镜像 运行5个容器作为一个服务，命名为web;限制每一个的资源：最多10%CPU的使用和50MB内存 如果有一个容器宕机，立马重启它这个容器 映射宿主机的4000端口到web该服务的80端口 这里面的5个容器通过负载均衡网络webnet共享80端口 定义一个默认配置的网络webnet，它是一个负载均衡的网络(load-balanced overlay network) 运行你的负载均衡APP在我们使用docker stack deploy前先执行下面的命令： 1docker swarm init 注意：如果你不运行docker swarm init你将得到一个错误：“this node is not a swarm manager” 运行 以上命令后，使用一下命令给你的负载均衡APP命名，这里名为getstartedlab : 1docker stack deploy -c docker-compose.yml getstartedlab 如果你运行起来有***.***.*** must be a mapping 就说明的你yml配置文件格式不对 好了，我们来看看这个服务是不是有5个容器在运行，使用以下命令查看服务： 1docker service ls 我们可以看到服务name 是getstartedlab_web ，就是APP名__服务名的结合。这里服务中的每一个容器称为任务(Task)，这些任务都分配着唯一的ID，查看该服务的详细任务列表： 1docker service ps getstartedlab_web 以上 看到服务里各个任务id，当然容器对于外部系统来说，也有容器id: 1docker container ls -q 现在你可以使用curl -4 http://localhost:4000多次执行，或多次浏览该URL，你会发现所有不同，他们真的负载均衡了。你可以看到变得是容器ID,就是上面docker containter ls -q的结果之一。 调控你的APP你可以修改docker-compose.yml里的replicas的值，然后保存，再次执行：修改前我查看一下容器id列表： 123456$docker container ls -q6e64e22402783ccbef3e8459985e1fec14828c7dbe7aad8d6633801d7557 这里我修改replicas为7，然后保存，再次执行以下命令： 1docker stack deploy -c docker-compose.yml getstartedlab 再查看容器id列表： 12345678$docker container ls -qcc9987a174f1e4b0337fed8d6e64e22402783ccbef3e8459985e1fec14828c7dbe7aad8d6633801d7557 发现它保留了原来的容器，并增加两个新的容器：cc9987a174f1和e4b0337fed8d，说明调控任务数量时，它不会把原来的全部容器杀死，而是一种更新。 关闭你的app和关闭swarm关闭app 1docker stack rm getstartedlab 关闭swarm: 1docker swarm leave --force 总结12345678docker stack ls # List stacks or appsdocker stack deploy -c &lt;composefile&gt; &lt;appname&gt; # Run the specified Compose filedocker service ls # List running services associated with an appdocker service ps &lt;service&gt; # List tasks associated with an appdocker inspect &lt;task or container&gt; # Inspect task or containerdocker container ls -q # List container IDsdocker stack rm &lt;appname&gt; # Tear down an applicationdocker swarm leave --force # Take down a single node swarm from the manager]]></content>
      <categories>
        <category>Docker</category>
        <category>Docker入门</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门-part2-Containers]]></title>
    <url>%2F2017%2F12%2F22%2Fdocker-part2%2F</url>
    <content type="text"><![CDATA[容器Containers前言本Docker入门系列文章是翻译于Docker官方getStarted文档,如有出入，请跳转查看官方文档 定义Dockerfile文件新建一个空目录，cd进去，然后新建一个文件叫Dockerfile拷贝下面的内容进去。 1234567891011121314151617181920# Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD ["python", "app.py"] the app itself再拷贝两个文件，requirements.txt和app.py。把他们放到Dockerfile的相同目录里。这样Dockerfile就可以“ADD . /app” 把他们两个文件放进image镜象里。 requirements.txt12FlaskRedis app.py123456789101112131415161718192021222324from flask import Flaskfrom redis import Redis, RedisErrorimport osimport socket# Connect to Redisredis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)app = Flask(__name__)@app.route("/")def hello(): try: visits = redis.incr("counter") except RedisError: visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;" html = "&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;" \ "&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;" \ "&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;" return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)if __name__ == "__main__": app.run(host='0.0.0.0', port=80) 我们就看到刚刚的”pip install -r requirements.txt”,就是读取requirements.txt里的文件，安装Flask和Redis的库文件给Python。我们设置的环境变量NAME 为World ,那么代码里的socket.gethostname()就可以获取World。 建立我们的APP我们先看看我们现有的文件： 12$ lsDockerfile app.py requirements.txt 创建一个镜像，使用 -t 为它名一个友善的名字friendlyhello: 1docker build -t friendlyhello . 你可以使用docker images 或docker image ls查看镜像列表 运行我们的APP使用-p去映射宿主机的4000端口到容器的80端口： 1docker run -p 4000:80 friendlyhello 去打开我们的浏览器浏览http://localhost:4000 如果你使用的是Window 7 的Docker Toolbox ，请求不是localhost,而是http://192.168.99.100:4000。如果还不是，使用docker-machine ip 查看具体的Docker Machine IP 你也可以使用curl命令发起请求： 123$ curl http://localhost:4000&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 8fc990912a14&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt; 使用Ctrl+C 退出以上的正在运行的容器 对于Window系统，可能Ctrl+C并不能完全退出，只是简单退出运行的页面，还得docker container ls查看正在运行的容器，接着就docker container stop &lt;Container NAME or ID&gt;来停止该容器 现在呢，我们来让容器在后台运行,使用-d： 1docker run -d -p 4000:80 friendlyhello 你就会得到一个很长的容器ID,这个容器已经在后台运行了，我们可以使用docker container ls来查看正在运行的容器。同时我们可以访问http://localhsot:4000。现在我们可以关闭该容器： 1docker container stop bb1dd75f205d 分享你的镜像使用Docker账号登录如果你还没有账号，请在cloud.docker.com注册。注册好后，在命令行登录： 1$docker login 为你的镜像打上标签Tag具体的语法：docker tag image username/repository:tag image：哪一个镜像名； username:用户名（一定要对上你的账户名）； repository:库名； tag ：版本号 例如：docker tag friendlyhello john/get-started:part2 发布你的镜像1docker push username/repository:tag 等一上传完后，可以登录Docker Hub，去查看你新分享的镜像。 拉取远程镜像并且运行它1docker run -p 4000:80 username/repository:tag 如果你本地没有这个镜像它会去远程拉取，否则运行本地的镜像。 总结12345678910111213141516docker build -t friendlyname . # 使用Dockerfile 创建一个镜像，并使用-t为镜像命名，注意别漏了最后那一点"."，它表示Dockerfile的当前目录。docker run -p 4000:80 friendlyname # 使用-p 映射宿主机的端口4000到容器的80端口，运行镜像docker run -d -p 4000:80 friendlyname #使用后台运行模式 -d docker container ls # 查看运行中的容器列表docker container ls -a # 查看所有容器，包括没有运行中的docker container stop &lt;hash&gt; # 根据hash值，停止容器docker container kill &lt;hash&gt; # 强行关闭某个容器docker container rm &lt;hash&gt; # 删除某个容器docker container rm $(docker container ls -a -q) # 删除所有容器docker image ls -a # 查看所有的镜像docker image rm &lt;image id&gt; # 根据镜像ID，删除镜像docker image rm $(docker image ls -a -q) # 删除所有的镜像docker login # 登录docker tag &lt;image&gt; username/repository:tag # 为某个镜像打上标签docker push username/repository:tag # 上次镜像到远程仓库docker run username/repository:tag # 从远程仓库里运行一个镜像，如果本地没有就先拉取再运行]]></content>
      <categories>
        <category>Docker</category>
        <category>Docker入门</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门-part1]]></title>
    <url>%2F2017%2F12%2F22%2Fdocker-part1%2F</url>
    <content type="text"><![CDATA[Docker HelloWorld前言本Docker入门系列文章是翻译于Docker官方getStarted文档,如有出入，请跳转查看官方文档 简单介绍容器 An image is a lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. 镜像是一种轻量级的、独立的、可执行的包，它包含运行一个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 A container is a runtime instance of an image—what the image becomes in memory when actually executed. It runs completely isolated from the host environment by default, only accessing host files and ports if configured to do so. 容器是镜像的运行时实例——当实际执行时，镜像会变成内存。默认情况下，它完全与主机环境隔离，如果配置为这样，则只能访问主机文件和端口。 Hello world1234567$ docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps:...(snipped)...]]></content>
      <categories>
        <category>Docker</category>
        <category>Docker入门</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在docker里部署zookeeper]]></title>
    <url>%2F2017%2F12%2F21%2Fdocker-zookeeper%2F</url>
    <content type="text"><![CDATA[部署Zookeeper单台机器部署3个zookeeper节点首先，初始化swarm 1docker swarm init 然后编辑一个文件,如下： docker-compose-single.yml 1234567891011121314151617181920212223242526272829303132333435363738394041version: '3.1'services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zoo3:2888:3888 zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=0.0.0.0:2888:3888 visualizer: image: dockersamples/visualizer:stable ports: - "8080:8080" volumes: - "/var/run/docker.sock:/var/run/docker.sock" deploy: placement: constraints: [node.role == manager] 以上的部署文件，定义了4个服务，3个zookeeper和visualizer，visualizer是一个可视化服务，待会你可以用浏览器访问8080端口，查看其他服务的可视化状态。 使用命令，查看zookeeper的启动情况： 1echo stat | nc 127.0.0.1 2181 或者 1echo stat | nc 127.0.0.1 2182 或者 1echo stat | nc 127.0.0.1 2183 如果显示如下内容，说明启动成功，zookeeper的容器已经绑定在你本机的2181,2182,2183端口上 123456789101112Zookeeper version: 3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMTClients: /10.255.0.2:56420[0](queued=0,recved=1,sent=0)Latency min/avg/max: 0/0/0Received: 1Sent: 0Connections: 1Outstanding: 0Zxid: 0x0Mode: followerNode count: 4 怎么使用zkCli.sh登陆客户端呢： 首先, 123456docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES99ee6c7335cd zookeeper:latest "/docker-entrypoin..." 17 hours ago Up 17 hours 2181/tcp, 2888/tcp, 3888/tcp zoolab_zoo2.1.0rfczhfcn1782fzpb2d6ir2iq0148b0cc522f zookeeper:latest "/docker-entrypoin..." 17 hours ago Up 17 hours 2181/tcp, 2888/tcp, 3888/tcp zoolab_zoo3.1.981cslrn7zqegvvp90r5vx5dme534fd292d3f zookeeper:latest "/docker-entrypoin..." 17 hours ago Up 17 hours 2181/tcp, 2888/tcp, 3888/tcp zoolab_zoo1.1.k45vcu9hqmzsxf8fg56b5hlx812e9ab6ae214 dockersamples/visualizer:stable "npm start" 17 hours ago Up 17 hours 8080/tcp zoolab_visualizer.1.hbg9c9sx9zd2c3obcaa9nbwgi 找到zookeeper的容器id : 99ee6c7335cd，0148b0cc522f，e534fd292d3f 我们现在选择一个容器id，进入容器: 12345678docker exec -it 99ee6c7335cd bashbash-4.4# lsLICENSE.txt bin dist-maven lib zookeeper-3.4.11.jar.ascNOTICE.txt build.xml docs recipes zookeeper-3.4.11.jar.md5README.md conf ivy.xml src zookeeper-3.4.11.jar.sha1README_packaging.txt contrib ivysettings.xml zookeeper-3.4.11.jarbash-4.4# ./bin/zkCli.sh （直接回车即可登陆zk客户端） 即可使用 zk 的 ls , get ,set ,create 等命令, 为了验证3个zookeeper之间的数据是互通的 我们可以登陆到一个容器里的zkCli创建一个节点数据： 123#容器99ee6c7335cd里的zkCli里输入[zk: localhost:2181(CONNECTED) 1] create /test 123456Created /test 我们登陆到另一台的容器的zkCli里： 1234567891011121314#容器0148b0cc522f里的zkCli里输入[zk: localhost:2181(CONNECTED) 1] get /test123456cZxid = 0x100000002ctime = Thu Dec 21 03:29:15 GMT 2017mZxid = 0x100000002mtime = Thu Dec 21 03:29:15 GMT 2017pZxid = 0x100000002cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 6numChildren = 0 如果在其他的容器里的zkCli能获取其他容器创建的节点数据，说明他们的数据是互通的。 多台机器部署3个zookeeper节点由于我们没有这么多台机器，我们将虚拟出其他3台虚拟机。 使用docker-machine 模拟3台机器： Mac,Linux,Win7,Win8 使用virtualbox 首先，您需要一个可以创建虚拟机(vm)的管理程序，因此为您的机器的操作系统安装Oracle VirtualBox。然后使用以下命令创建多台虚拟机 123docker-machine create --driver virtualbox myvm1docker-machine create --driver virtualbox myvm2docker-machine create --driver virtualbox myvm3 Win10 使用 hyper-V 登陆Hyper-V 管理系统 点击右边菜单的Virtual Switch Manager 在External里点击Create Virtual Switch 给给他一个名字myswitch ,选中该复选框以共享主机的活动网络适配器 现在，使用我们的节点管理工具docker-machine创建几个vm 123docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm2docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm3 接下来我们创建一个部署文件： docker-compose-swarm.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152version: '3.1'services: zoo1: image: zookeeper restart: always hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 networks: - webnet zoo2: image: zookeeper restart: always hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 networks: - webnet zoo3: image: zookeeper restart: always hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888 networks: - webnet visualizer: image: dockersamples/visualizer:stable ports: - 8080:8080 volumes: - "/var/run/docker.sock:/var/run/docker.sock" deploy: placement: constraints: [node.role == manager] networks: - webnetnetworks: webnet: driver: overlay 好了，在我们部署之前，我们需要定义好，myvm1为manager,myvm2和myvm3为worker。所以，我们先登陆到myvm1里去初始化swarm(前面也初始化过swarm,不过是单台机器)，然后把myvm2和myvm3加入到这个swarm中，最后才运行部署文件。具体操作如下： 设置终端环境我们不是要去登陆到myvm1里，而是获取myvm1的终端环境到本机的终端，在本机终端操作，从而操作虚拟机。 Mac,Linux 123456789101112docker-machine env myvm1#按提示，继续输入命令：eval $(docker-machine env myvm1)#查看docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 * virtualbox Running tcp://192.168.99.100:2376 v17.06.2-ce myvm2 - virtualbox Running tcp://192.168.99.101:2376 v17.06.2-ce 在myvm1 旁边多了个星号，表示成功 Winodow 12345678910111213docker-machine env myvm1#按提示，继续输入命令：&amp; "C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe" env myvm1 | Invoke-Expression#查看docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 * hyperv Running tcp://192.168.203.207:2376 v17.06.2-cemyvm2 - hyperv Running tcp://192.168.200.181:2376 v17.06.2-ce在myvm1 旁边多了个星号，表示成功 我们获取好myvm1终端环境，然后我们初始化swarm 12345678docker swarm init --advertise-addr &lt;myvm1 ip&gt;Swarm initialized: current node &lt;node ID&gt; is now a manager.To add a worker to this swarm, run the following command: docker swarm join \ --token &lt;token&gt; \ &lt;myvm ip&gt;:&lt;port&gt; 它这里提示我们登陆到其他的worker里,输入它上面给出的命令。 1234567#获取myvm2的终端环境eval $(docker-machine env myvm2)#加入swarmdocker swarm join \ --token &lt;token&gt; \ &lt;myvm ip&gt;:&lt;port&gt; 类似的，我们把myvm3也加入swarm来。 现在我们要登陆到myvm1里，因为它是manager,用它来进行部署 12345678#登陆myvm1eval $(docker-machine env myvm1)#部署docker stack deploy -c docker-compose-swarm.yml zklab#查看docker stack ps zklab 验证zookeeper 123echo stat | nc &lt;myvm1/2/3 ip&gt; 2181echo stat | nc &lt;myvm1/2/3 ip&gt; 2182echo stat | nc &lt;myvm1/2/3 ip&gt; 2183 用浏览器查看：http://myvm1/2/3_ip:8080]]></content>
      <categories>
        <category>Docker</category>
        <category>部署例子</category>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
</search>
